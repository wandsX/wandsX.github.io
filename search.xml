<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cs值类型和引用类型]]></title>
    <url>%2F2019%2F12%2F30%2Fcs%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[学习C#的值类型和引用类型 1.类型划分一个类型要么是值类型，要么是引用类型。 区别在于拷贝方式：值类型的数据总是拷贝值，引用类型数据总是拷贝引用 1.1 值类型将一个值赋值给变量1，再将变量1赋值给变量2，会在变量2的位置创建值的拷贝，而不是引用变量1的位置。也就是说改变 变量1的值不会影响到变量2的值。 1.2 引用类型引用类型的变量存储数据存储位置的引用，而不是直接存储数据。 用c/cpp的意思理解就是指针，存放的数据的地址。（存放在堆中） 2.可空修饰符一般不将null值赋值给值类型。可控修饰符？ int? count = null; 在c#3.0可以使用 var 来声明隐式类型的局部变量。声明变量时，如果能用确定类型的表达式初始化它，就允许变量的数据类型“隐式。 当然在数据类型已知的情况下最好不要用 var 关键字，这增加了代码的可读性。 c# var 由编译器严格确定类型 ，确定之后不在更改，比如Javascript中将一个变量为var,可以将不同类型重新赋值给这些变量。 2.1 匿名类型var支持匿名类型。 匿名类型式在方法内部动态声明的数据类型，而不是通过显式的类定义来声明。 var patent = new {Title = &quot;BIf&quot;, YearOfPublication = &quot;1784&quot;}; 3.元组这是c#7.0的新语法。 元组的声明和赋值的示例。]]></content>
      <categories>
        <category>c#本质论</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>c# 语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs语法数据类型]]></title>
    <url>%2F2019%2F12%2F20%2Fcs%E8%AF%AD%E6%B3%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[学习C#数据类型 1.基本数据类型c#基本数据类型包括：整数类型， 浮点类型，decimal类型（特殊的浮点类型，能存储大数字而无表示错误）。 1.1 整数类型 \begin{array}\\ {\text {类型}} & { \text { 大小 }} & {范围} & {\text { BCL名称}}\\ {\text { sbyte }} & {8 \text { 位 }} & {-128-127} & {\text { system. SByte }} \\ {\text { byte }} & {8 \text { 位 }} & {0-255} & {\text { system. Byte }} \\ {\text { short }} & {16 \text {位 }} & {0-255} & {\text { System. Int16 } }\\ {\text { ushort }} & {16 \text { 位 }} & {0-32768-32767} & {\text { System. UInt 16 } } \\ {\text { int }} & {32 \text { 位 }} & {0-65535647483647} & {\text { system. Int 32 }} \\ {\text { uint }} & {32 \text { 位}} & {0-4294967295} & {\text { System. UInt 32 }} \\ {\text { Long }} & {64 \text { 位 }} & {-9223372036854775808-9223372036854775807}& {\text { System. Int 64 }} \\ {\text { ulong }} & {64 \text { 位 }}&{0-18446744073709551615} & {\text { system. UInt } 64} \end{array} BCL名称是基类库中的类型名称。 设计规范：指定数据类型时使用c#关键字而不是BCL名称，且保持一致。 1.2 浮点类型 \begin{array}\\ \hline \text{类型} & {大小} & { 范围 } & {BCL名称} & {有效数位} & {后缀} \\ \hline \text { float } & {32位} & {\pm 1.5 \times 10^{-3}-\pm 3.4 \times 10^{35}} & {\text { System. Single }} & {7} & {F \text { 或 f}} \\ \hline \text { double } & {64 \text { 位 }} & {\pm 5.0 \times 10^{-134}}{-\pm 1.7 \times 10^{100}} & {\text { System. Double }} & {15-16} & {\text { D 或 d}} \\ \hline \end{array}1.3 decimal类型c#提供了128位精度的十进制浮点类型。 \begin{array}\\ \hline \text {类型} & {大小 }& {范围} & {BCL名称} & { 有效数位 } & {后缀} \\ \hline \text { decimal } & 128 \text { 位 } &\left(-7.9 \times 10^{3}-7.9 \times 10^{8}\right) /\left(10^{6}-10^{8}\right) & \text { system. Decimal } & 28-29 & \text { M或 } m\\ \hline \end{array}decimal类型和浮点数不一样，decimal类型保证范围内所有十进制数都是精确的。所以0.1就是0.1,而不是近似值。 此外decimal类型精度很高，但是范围较小。 1.4 字面值表示源代码中的固定值。 // 如下面的42和1.523 Console.WriteLine(2); Console.WriteLine(1.523); 如果直接将值放入源代码中，被称为：硬编码， 通常这样做会使得代码很难维护，有可能需要进行再次编译才能继续使用。所有一种解决办法是直接读取配置文件中所设立的值，在需要改动的时候，直接进行修改配置文件的值即可。 对于字面值的输出： Console.WriteLine(1.618033988749895); // 输出不精确的值 &gt;&gt; 1.61803398874989 Console.WriteLine(1.618033988749895M); // 加上后缀，输出精确的值 &gt;&gt; 1.61803398874989 F和D将字面值分别显式声明没float,double。 对于整数类型，相应后缀是U, L, LU, UL。 无后缀的数值字面值按以下顺序解析成能存储该值的第一个数据类型：int, uint, long, ulong. 后缀为U的数值子面子按以下顺序解析成能存储该值的第一个数据类型：uint, ulong。 后缀为L的数值字面值按以下顺序解析成能存储该值的第一个数据类型：long, ulong. 2. 更多基本类型2.1 布尔类型占用一个字节。 2.2 字符类型char类型的BCL名称是：System.Char。 2.3 字符串类型string类型的BCL名称是：System.String. 支持字面值格式，逐字前缀@，允许$前缀进行字符串插值。string是一种“不可变”类型。 逐字和插值形式可以组合使用。 2.3.1 字面值格式构造字符串2.3.2 前缀@格式输出字符串@指明转义序列不被处理，结果是一个逐字字符串字面值，不仅将反斜杠当作普通字符，还会逐字解释所有空白字符。@开头的字符串唯一支持的转义序列是 “”代表是一个双引号。 2.3.4 $字符串插值字符串插值本质上事C#的一个语法糖。 Console.WriteLine($&quot;Your full name is {firstName} {lastName}.&quot;); // 上述代码会转换成下面的代码 object[] args = new object[] { firstName, lastName }; Console.WriteLine(string.Format(&quot;Your full name is {0} {1}.&quot;, args)); 3. null 和 void3.1 nullnull可直接赋值给字符串变量，表明变量为“空”，不指向任何位置。 只能将null赋值给引用类型，指针类型， 可空值类型。 赋值了null的变量已设置，而未赋值的变量会造成编译时错误。 3.2 void void 本质上不是数据类型，它只是指出没有数据类型。 4.数据类型转换4.1 显式转换写法：（type）。 4.1.1 checked 和 unchecked转换static void Main(string[] args) { // checked快代码在运行时发生赋值溢出将引发异常。 checked { int n = int.MaxValue; n = n + 1; Console.WriteLine(n); } } c#提供一个命令行选项将默认行为从unchecked改为checked。 也支持unchecked快来强制不进行溢出检查，块中溢出的赋值不会引发异常。 4.2 隐式转换不多比比。 4.3 不适用转型操作符的类型转换4.3.1 Parse()方法每个数值数据类型都包含一个Parse() 方法，允许将字符串转换成对应的数值类型。 string text = &quot;9.11E-31&quot;; float value = float.Parse(text); 4.3.2 System.Convert进行类型转换string middleText = &quot;241.626&quot;; double middleC = System.Convert.ToDouble(middleText); bool boolean = System.Convert.ToBoolean(middleC); Convert只支持少量类型，且不可扩展，允许从bool char sbyte short int long ushort uint ulong float double decimal DateTime string 转换到这些类型中的任何一种。 4.3.3 ToString转换成string4.3.4 TryParse()和Parse()方法非常相似，只是转换失败而不是引发异常，而是返回false. static void Main(string[] args) { Console.Write(&quot;Enter a number: &quot;); string input = Console.ReadLine(); /* c#7.0之前的版本对于number要先声明才能使用。 */ if (double.TryParse(input, out double number)) { Console.WriteLine(number); } else { Console.WriteLine( &quot;The text entered was not a vaild number.&quot; ); } }]]></content>
      <categories>
        <category>c#本质论</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>c# 语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解cs泛型]]></title>
    <url>%2F2019%2F12%2F13%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cs%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这篇文章学习一下c#的泛型 基本概念泛型分为两种形式：泛型类型（接口，委托，结构，类）和 泛型方法，两者都是表示API的基本方法。 我们看下面的两个语句： Dictonary&lt;TKey, TValue&gt; // 未绑定泛型 Dictonary&lt;string, int&gt; // 已构造类型 类型参数是TKey, TValue，而类型实参是string, int。 类型参数“接收信息”，类型实参提供信息。 如果没有为泛型类型参数提供类型实参，那么这就是一个未绑定泛型类型。如果制定了类型实参，该类型就是一个已构造类型。 public class Dictionary&lt;TKey, TValue&gt; // 声明泛型类型 : IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; // 实现泛型接口 { public Dictionary() { } // 无参构造函数 public void Add(TKey key, TValue value) // 类型参数声明方法 { } } // list&lt;T&gt; 读作list of T 泛型可以重载，只需要改变一下类型参数的数量。 泛型方法概念属于比较简单，我们通过之下的例子来说明 class Program { static double TakeSquareRoot(int x) { return Math.Sqrt(x); } static void Main(string[] args) { List&lt;int&gt; interges = new List&lt;int&gt;(); interges.Add(1); interges.Add(3); interges.Add(4); interges.Add(5); // &lt;int double&gt; 代表转换 Converter&lt;int, double&gt; converter = TakeSquareRoot; // 创建委托实例 List&lt;double&gt; doubles; doubles = interges.ConvertAll&lt;double&gt;(converter); // 调用泛型方法 foreach(double d in doubles) { Console.WriteLine(d); } } } 非泛型同样可以使用泛型方法 class Program { static List&lt;T&gt; MakeList&lt;T&gt; (T first, T second) { List &lt;T&gt; list = new List&lt;T&gt;(); list.Add(first); list.Add(second); return list; } static void Main(string[] args) { List&lt;string&gt; list = MakeList&lt;string&gt;(&quot;line1&quot;, &quot;line2&quot;); foreach(string x in list) { Console.WriteLine(x); } } } 泛型的类型约束​ 类型约束是为了只有特定的类型调用，相当于制定了规则，从而判断哪些是泛型类型或泛型方法能接受的有效类型实参。 约束类型引用类型约束用于确保使用的类型是引用类型。 struct RefSample&lt;T&gt; where T : class // 有效 RefSample&lt;string&gt; RefSample&lt;int[]&gt; RefSample&lt;IDisposable&gt; // ..无效 RefSample&lt;Guid&gt; RefSample&lt;int&gt; RefSample 仍然是值类型，以强调被约束的类型参数和类型本身的差异。 值类型约束确保使用的类型实参是值类型。 class ValSample&lt;T&gt; where T : struct // ..有效 ValSample&lt;int&gt; ValSample&lt;FileMode&gt; // ..无效 ValSample&lt;object&gt; ValSample&lt;StringBuilder&gt; ValSample类型本身是一个引用类型，虽然T被约束成值类型。 构造函数类型约束​ 此约束表示成T：new T ( ), 必须是所有类型参数的最后一个约束，它检查和类型实参是否有一个可用于创建类型实例的无参构造函数。 适用于： 所有值类型 所有没有显式声明构造函数的非静态，非抽象类 所有显式声明了一个公共无参构造函数的非抽象类 转换类型约束​ 允许你指定另一个类型，类型实参必须可以通过一致性，引用或装箱转换隐式地转换为该类型。你还可以规定一个类型实参必须可以转换为另一个类型实参，这成为类型参数约束。 class Sample&lt;T&gt; where T : Stream Sample&lt;Stream&gt; // 一致性转换 Sample&lt;string&gt; // 无效 struct Sample&lt;T&gt; where T : IDispossable Sample&lt;SqlConnection&gt; // 引用转换 Sample&lt;StringBuilder&gt; // ..无效 class Sample&lt;T&gt; where T : IComparable&lt;T&gt; Sample&lt;int&gt; //装箱转换 Sample&lt;FileInfo&gt; // 无效 class Sample&lt;T, U&gt; where T : U Sample&lt;Stream, IDisposable&gt; // 引用转换 Sample&lt;string, Idisposable&gt; // 无效 // 可以指定多个接口，但只能指定一个类。 class Sample&lt;T&gt; where T : Stream, IEnumerable&lt;string&gt;, IComparable&lt;int&gt; // ..error class Sample&lt;T&gt; where T : Stream, ArrayList,IComparable&lt;int&gt; 还有一系列限制：指定的类不可以是结构，密封类（比如string) 或者一下任何“特殊”类型。 System.Object System.Enum; System.ValueType; Systenm.Delegate; 组合约束组合约束是以上四种约束的组合，在c#中，不可能任何类型即是引用类型，又是值类型。遵循以下基本要点： class 或 struct 约束必须在其他约束之前，构造函数约束必须在最后。 指定类约束就不能指定值类型约束和引用类型约束 但是每一个值类型都有一个无参构造函数，所以假如已经有一个值类型约束，就不允许再指定一个构造函数约束。（如果T被约束成一个值类型，仍然可以在方法内部使用 new T() ）. 其次，如果存在多个转换类型约束，并且其中一个为类，那么它应该出现在接口的前面，而且我们不能多次指定同一个接口。不同的类型参数可以有不同的约束，它们分别由一个单独的where引入。 说这么多不如看看下面的例子 /* 有效 */ // 值约束，转换类型约束，构造函数类型约束 class Sample&lt;T&gt;:where T : class, IDisposable, new(){...} // 引用约束，转换类型约束 class Sample&lt;T&gt; : where T : struct, IDisposable{...} // 前面的一句T是值类型约束，后面的U是引用约束加上T的转换类型约束 class Sample&lt;T, U&gt; : where T : class where U: struct, T{...} // 前面T的是转换类型约束，后面的U是转换类型约束， 类写在前面 class Sample&lt;T, U&gt; : where T : Stream where U : IDisposable{...} /* 无效 */ // 引用类型和值类型约束一起 class Sample&lt;T&gt;where T : class, struct{...} // 值类型约束要在其他类型约束前面，指定类约束就不能指定值类型约束和引用类型约束 class Sample&lt;T&gt; where T : Stream, class{...} // new() 必须是最后一个约束 class Sample&lt;T&gt; where T : new(), Stream{...} // 类约束要在接口约束之前 class Sample&lt;T&gt; where T : IDisposable, Stream{...} // 多次指定同一个接口 class Sample&lt;T&gt; where T : XmlReader, IComparable, IComparable{...} // 因为T具有引用类型约束，不能作为U的约束 class Sample&lt;T, U&gt; where T : struct where U class, T {...} 如果我们从规范中对约束进行分类，将其划分为主要约束，次要约束，构造函数约束。 主要约束：引用类型约束，值类型约束，使用类的转换类型约束 次要约束：接口或其他类型参数的转换类型约束 因此我们可以从规范上得知：三种约束都是可选的，但是主要约束只能有一个，次要约束只能有一个。 如果是值类型约束，就不能使用构造函数约束了，因为值类型默认都带有一个无参构造函数。 实现泛型默认值表达式有些情况虽然一般会被视为错误，但并不是十分严重的问题，也不应该视为异常。例如用户在键入的时候，由于输入一些非法的字符，程序假如能尝试解析一下文本，不必处理错误和捕捉异常，那么在容易出错的地方，可以提升性能。 在c#中，可以采取默认值表达式来解决这个问题。 static int CompareToDefault&lt;T&gt;(T value) where T : IComparable&lt;T&gt; { // CompareTo对于所有的引用类型的值都大于null,所以大于1. return value.CompareTo(default(T)); } static void Main(string[] args) { Console.WriteLine(CompareToDefault(&quot;x&quot;)); Console.WriteLine(CompareToDefault(10)); Console.WriteLine(CompareToDefault(0)); Console.WriteLine(CompareToDefault(-10)); Console.WriteLine(CompareToDefault(DateTime.MinValue)); } 直接比较 如果一个类型参数是未约束的，那么只能在将该类型的值与null比较时才能使用== 和 ！= 操作符，不能直接的比较 如果类型实参是一个引用类型，会进行正常的引用比较。 如果为T提供的类型实参是一个非可空值类型，与null进行比较结果总是显示它们不相等。 如果类型实参是一个可空值类型，那么自然而然会与类型的控制进行比较。 如果一个类型参数被约束为值类型，就完全不能为它使用== 和 ！=。 如果被约束为引用类型，那么具体执行的比较将完全取决于类型参数被约束成什么类型。 如果它只是一个引用类型，那么执行只是简单的引用比较。 如果它被进一步约束成继承自某个重载了== 和 ！= 操作符的特定类型，就会使用重载的操作符。但要注意，假如调用者指定的类型实参恰巧也进行了重载，那么这个重载操作符是不会使用的。 ```c#static bool AreReferencesEqual(T first, T second) where T : class { return first == second; } static void Main(string[] args) { string name = &quot;jon&quot;; string intro1 = &quot;My name is &quot; + name; string intro2 = &quot;My name is &quot; + name; Console.WriteLine(intro1 == intro2); Console.WriteLine(AreReferencesEqual(intro1, intro2)); } truefalse ```]]></content>
      <categories>
        <category>深入理解c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 c# 值类型和引用类型]]></title>
    <url>%2F2019%2F12%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cs%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这篇文章学习一下c#的值类型和引用类型 简要分类 数组类型是引用类型，即使元素是值类型 枚举是值类型 委托类型是引用类型 接口类型是引用类型，但可以由值类型实现 类是引用类型，结构是值类型 三个误区： 结构是轻量级得类 引用类型保存在堆上，值类型保存在栈上引用类型一般都是创建在堆上，例如类实例，大但是值类型不一定都保存在栈上，比如类实例中属性，如果学过csapp,我们可以得知往往是函数参数和局部变量保存在栈上，静态变量则保存在堆上。 对象在c#中默认是通过引用传递的无论是引用传递还是值传递，永远不会传递对象本身，举个例子，在c/c++中使用指针，传递得是对象本身所在得地址而不是对象。]]></content>
      <categories>
        <category>深入理解c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const对指针和引用的限定]]></title>
    <url>%2F2019%2F12%2F08%2Fc%2B%2B-primer-const%E5%AF%B9%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E9%99%90%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[本文讲述const和指针，引用之间微妙的关系 const与引用const的引用（reference to const)简称为常量引用，引用的对象时常量还是非常量可以决定其所参与的操作，但是不会影响引用和对象的绑定关系。 const int ci = 1024; const int &amp;r1 = ci; // 引用及其对应的对象都是常量 r1 = 42; int &amp;r2 = ci; // error, 使用一个非常量引用指向一个常量。 int i = 42; const int &amp;r4 = r3; // 常量引用可以指向一个非常量，但是不允许通过r4对r3进行修改。 const与指针指向常量的指针(pointer to const) 指向常量的指针没有规定其所指的对象必须是一个常量,指向常量的指针是指不能通过指针来改变所指的变量的值。。 const double pi1 = 3.14; double pi2 = 3.14; // 下面两条赋值语句都是合法的。 const double *cptr1 = &amp;pi1; const double *cptr2 = &amp;pi2; 常量指针(const pointer) 常量指针必须初始化，一旦初始化完成，那么它的值将不会在变化。 const poiter 不变的是指针本身的值而不是所指向的那个值，所以const pointer可以通过指针修改所指对象的值。```cppint errNum = 0;int *const curErr = &errNum; const double pi = 3.14;// 将放在const可以说明指针是一个常量const double const pip = &pi; // pip是一个指向常量对象的常量指针。 ### const 介绍 - 顶层 const 代表对象本身是个常量。 - 底层 const 代表指针所指的对象是一个常量。 - 指针既可以是顶层const，也可以是底层const ```cpp int i = 0; int *const p1 = &amp;i; // const pointer -- 这是顶层const const int ci = 42; // const var -- 这是顶层const const int *p2 = &amp;ci; // pointer to const -- 这是底层const const int *const p3 = p2; // 右边是顶层const， 左边是底层const const int &amp;r = ci; // 用于声明引用的const 都是底层const 如果进行copy时，顶层const的不受影响，但是底层const受限制。 进行copy的对象，拷入和拷出必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，但是反之不行。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第三章学习笔记]]></title>
    <url>%2F2019%2F12%2F08%2Fc%2B%2B-primer-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章主要介绍函数的定义和声明 函数函数的基础就不多说了。 函数的调用完成两项工作: 实参初始化函数对应的形参 将控制权转移给被调用函数 参数传递在c++中，多使用引用代替指针。 const形参和实参 const对 形参和实参 的作用和对变量的引用是一致的。 数组形参在cpp中，数组的两个特殊性质 不能copy，所以数组不能以值传递的方式使用数组参数。 不能用一个数组对另外一个数组进行初始化，也不能直接赋值 传递数组通常转换为```cpp // 以下三种语法是等价的。void function(int *);void function(int []);void function(int [10]); ##### 管理指针形参的三种方式 - 使用标记，如C风格字符串 ```cpp void print(const char *cp) { if (cp) while (*cp) cout &lt;&lt; *cp++ &lt;&lt; &quot; &quot;; } 使用标准库规范 void print(const char* begin, const char* end) { while (begin != end) { cout &lt;&lt; *begin++ &lt;&lt; endl; } } 显示的传递一个代表数组大小的形参 void print(const int ia[]， size_t size) { for(size_t i = 0; i != size; ++i) { cout &lt;&lt; ia[i] &lt;&lt; endl; } }]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第三章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Fc%2B%2B-primer-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文初识标准库和迭代器,以及using在 c++11中新用处。 3.1 using 声明头文件不应该使用using 声明,因为头文件的内容会拷贝到所有引用它的文件中。这样容易产生名字冲突。 3.2 string初始化string s1; // 默认初始化 空串 string s2(s1); // s2是s1的副本。 string s2 = s1; // 等价于s2(s1)。 string s3(&quot;value&quot;); // 等价写法 string s3 = &quot;value&quot;; string s4(n, &#39;c&#39;); // s4为连续n个字符c组成的字符串。 如果使用等号初始化一个变量的时候, 实际上执行的是拷贝初始化。反之则是直接初始化。 读写string 对象int main() { string str; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; return 0; } string对象回自动忽略开头的空白(空格符, 换行符, 制表符等)并从第一个真正的字符开始读起,直到遇到下一个空白开始。 getline读取一整行，直到遇到换行符，所读的内容存入string对象中。换行符也被读进来了,但是被丢弃了,并没有存储到string对象中 size()函数的返回值是string::size_type类型,这是一个与机器无关的无符号整数类型。 所以当出现string.size()就不要使用int了。 string的比较关系运算符 &lt; &lt;= &gt; &gt;=都遵循以下的字典顺序 如果两个string对象的长度不同,而且较短string对象的每个字符都与较长string对象对应位置上的字符相同,就说较短的小于较长的。 如果两个string对象在某些对应位置上不一致,则string对象比较的结果实际上是第一对相异字符比较的结果。 3.3 vector实例化:编译器根据模板创建类和函数的过程。 初始化vector(T) v1; // v1是一个空vector,执行T类型的默认初始化。 vector(T) v2(v1); // v2中包含了v1所有元素的副本。 vector(T) v2 = v1; //等价于v2(v1)。 vector(T) v3(n, nval); // v3包含了n个重复的元素,每个元素的值都是val。 vector(T) V4(n); // n个执行了T类型的值初始化的对象。 // 列表初始化 vector(T) v5{a, b, c ...} // v5包含了初始值个数的元素。 vector(T) v5 = {a, b, c ...} // 等价于v5{a, b, c ...} 添加元素push_back()添加到vector的尾端。 c++ 更习惯于先创建空的vector对象,在运行的时候动态添加元素。 vector不能使用下标运算符去添加元素,但是可以用于访问已经存在的元素。 迭代器怎样称为一个有效的迭代器呢？ 或者指向某个元素,或者指向容器中尾元素的下一个位置 怎样获取迭代器？ begin() 和 end() ：end()获取的是一个尾后迭代器,指向尾部元素的下一个位置,仅仅是一个标记而已。 end() 返回的迭代器并不实际指示某个元素,所以不能对其进行递增或解引用的操作 但凡是使用了迭代器的循环体,都不要向使用迭代器所属的容器添加元素。因为会使迭代器失效。 迭代器运算所有标准库容器都有支持递增运算的迭代器。 string和vector迭代器支持更多运算。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第二章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Fc%2B%2B-primer-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章主要讲述了c++变量声明,以及各种修饰符的作用和技巧 [toc] 0x00. 变量初始化和赋值初始化指变量在创建时给它赋予一个初始值，赋值是将当前对象的值擦除掉,而以一个新值来代替. 0.1 列表初始化下面四条语句都可以定义int类型的units_sold的变量并初始化为0. int units_sold = 0; int units_sold = {0}; int units_sold{0}; int units_sold(0); long double ld = 3.1415926536; int a(ld), b = {ld}; // 错误： 转换未执行，因为存在丢失信息的危险。 int c(ld), d = ld; // 正确：转换执行，且确实丢失了部分值。 0.2 默认初始化如果定义变量时没有指定初值，则变量被默认初始化( default initialized), 此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化(uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。 每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。 0x01. 声明和定义声明: 使得名字被程序所知道,一个文件如果想使用别处定义的名字则必须包含那个对那个名字的声明。 定义: 负责创建和名字关联的实体 声明一个变量而非定义它,就在变量名前添加关键字extern,而且不要显示化的初始化变量。 extern int i; // 声明但没定义 int j; //声明并定义 extern double pi = 3.1416; // 定义 变量只能被定义一次,但是可以被多次声明。 引用必须初始化 void* 可以存放任意对象的地址 0x02. 字面值常量2.1 字面值介绍一个形如42的值被称为字面值常量。字面值是指只能通过它的值来称呼它，没有别名。 类似的字符字面值和字符串字面值，‘a’, “hello world!” 2.2 指定字面值的类型 auto char_1 = L&#39;a&#39;; auto string_1 = u8&quot;hi!&quot;; auto ulonglong_1 = 42ULL; auto float_1 = 1E-3F; auto ldouble_1 = 3.14159L; 布尔类型的字面值是true 和 false. 而指针类型的字面值是nullptr 2.3 练习 2.3.1(a)组的数据类型分别是 char, wchar_t, const char, const wchar_t 。 (b)组的数据类型分别是 int, unsigned int, long, unsigned long, 八进制的10, 十六进制的12。 (c)组的数据类型:第一个却决于你所声明变量的类型，若是依靠编译器自动推导,类型是double. ​ 后面两个分别为float, long double. (d) 组的数据类型:int, unsigned int , 第三个为float或double，double。 2.3.2有区别，上面一组定义的字面值为十进制，下面一组定义的字面值为八进制。 2.3.31024F 存在语法错误，编译不通过。 \145 值为’e’, \012值为 ‘\n’ 3.14e1L为long double. 0x03. const限定符const对象必须初始化 指向常量的指针和应用都是自以为是,就是不能通过本身去改变指向对象的值。 3.1 const 指针int *const ptr = &var; 常量指针必须初始化。 常量指针能不能通过指针去修改所指向对象的值,却决于指向对象的类型。 顶层const : 表示本身是一个常量 底层const : 表示指向的对象是一个常量 0x04. constexpr常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。 const int buf_size = 20; // 常量表达式 const int limit = buf_size + 1 // 常量表达式 int size = 10; // 不是常量表达式 constexpr : 由编译器来验证变量的值是否为常量表达式。 声明为constexpr变量一定是一个常量,而且必须用常量表达式初始化, constexpr 指针初始值一定要是nullptr 或 0 0x05. autoauto 一般会忽略掉顶层const，保留底层const。 int i = 0; const int ci = i, &amp;cr = ci; auto b = ci; // b是一个整数 const特性被忽略掉 auto a = cr; // c是一个整数 auto d = &amp;i; // d是一个整形指针 auto e = &amp;ci; // e是一个指向常量整数的指针 底层const const auto f = ci; // 这个时候f才有顶层const特性。 0x06. decltype decltype(( variable ))结果永远是引用 decltype( variable ) 只有variable本身是引用才是引用。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
</search>
