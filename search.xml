<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++ primer 第九章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Findex-1%2F</url>
    <content type="text"><![CDATA[本章介绍了STL的语法。 9.1概述 name instruction vector 可变大小的数组,支持快速随机访问.在尾部之外的位置插入或删除元素可能很慢 deque 双端队列。支持快速随机访问,在头尾位置插入/删除速度很快 list 双向链表。只支持双向顺序访问.在list中任何位置插入/删除操作速度都很快。 forward_list 单向链表.只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 array 固定大小数组。支持快速随机访问,不能添加元素或删除元素。 string 随机访问快,与vector类似,但专门用于保存字符.在尾部插入/删除速度快。 选择容器的原则 首选vector,除非你有更好的选择 如果你的程序有很小的元素,且空间的额外开销很重要.则不要使用list或forward_list。 如果程序要求随机访问元素,应使用vector或deque。 如果程序要求在容器的中间插入或删除元素,应使用list或forward_list 如果程序要求在首尾端插入或删除元素,但不会在中间位置进行插入或删除操作。用deque 如果你不确定使用哪种容器,那么可以在程序中只使用vector和list公共的操作:使用迭代器,不使用下标操作,避免随机访问。这样,在必要时选择使用vector或list方便。 9.2容器操作表 类型别名 说明 iterator 迭代器类型 const_itertor 只读迭代器 size_type 无符号整数类型,足够保存容器类型最大可能容器的大小 difference_type 带符号整数类型,保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型,与value_type&amp;含义相同 构造函数 说明 C c 默认构造函数,空容器 C c1(c2) 构造c2的拷贝c1 C c(b, e) 构造c, 将迭代器b和e指定范围内的元素拷贝到c(不支持array) C c{a, b, c…}; 列表初始化 添加删除函数(不适用于array) 构造函数 说明 c.insert(args) 将args中的元素copy到c c.emplace(inits) 使用inits构造c中的一个元素 c.erase(args) 删除args指定的元素 c.clear() 删除c中的所有元素。 关系运算符所有容器都支持相等(不等)运算符,&lt;, &lt;=, &gt;, &gt;= (无序关联容器不支持) 9.2.1 迭代器forward_list 迭代器不支持递减运算符(–) 标准库使用左闭合范围的好处 假定begin和end构成了一个合法的迭代器范围. 如果begin和end相等,则范围为空 如果begin和end不等,则范围至少包含一个元素,且begin指向该范围中的第一个元素 我们可以对begin递增若干次,使得begin==end 9.2.2 容器类型成员值得注意的是: begin()返回是否为const_iterator 取决于容器类型是否为const. cbegin() cend()返回就是const_iterator 与容器类型是否为const无关。 auto 前面加const 保证了顶层const的特性。 9.2.4容器的初始化创建一个容器为了和容器实现匹配, 必须保证容器类型的高度一致。 12345678list &lt;string&gt; l1 = &#123;"sadd", "hello ", "world"&#125;;vector(const char*) a1 = &#123;"a", "an", "bre"&#125;;deque &lt;string&gt; d1(l1); vector&lt;string&gt; words(a1); // 容器类型匹配不一致。forward_list&lt;string&gt; words (a1.bengin(), a1.end()); // 但是可以通过两个迭代器所代表的范围来初始化。 9.2.5 赋值和交换容器的赋值运算 swap函数()swap(contains, contains)比拷贝元素要快。 除了array之外,swap函数不对任何元素进行拷贝,删除或插入操作,因此可以保证在常数时间完成。 除了string之外,swap函数执行之后,容器的迭代器,引用和指针都不会失效。 建议使用非成员函数版本的swap函数 assign操作不适用于关联容器和array 12345678910111213141516int main(int argc, char const *argv[])&#123; list&lt;int&gt; l1 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;int&gt; v2 = &#123;100, 1000, 10000&#125;; l1.assign(v2.begin(), v2.end()); for (auto it : l1) &#123; cout &lt;&lt; it &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; output: 100 1000 10000 arrayarray初始化必须指定大小]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第二章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Fc-primer-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章主要讲述了c++变量声明,以及各种修饰符的作用和技巧 初始化指变量在创建时给它赋值。赋值是将当前对象的值擦除掉,而以一个新值来代替.声明和定义的关系声明: 使得名字被程序所知道,一个文件如果想使用别处定义的名字则必须包含那个对那个名字的声明。 定义: 负责创建和名字关联的实体 声明一个变量而非定义它,就在变量名前添加关键字extern,而且不要显示化的初始化变量。 123extern int i; // 声明但没定义int j; //声明并定义extern double pi = 3.1416; // 定义 变量只能被定义一次,但是可以被多次声明。 引用必须初始化 void* 可以存放任意对象的地址 const 限定符const对象必须初始化指向常量的指针和应用都是自以为是,就是不能通过本身去改变指向对象的值。 const 指针 int *const ptr = &var; 常量指针必须初始化。 常量指针能不能通过指针去修改所指向对象的值,却决于指向对象的类型。 顶层const : 表示本身是一个常量 底层const : 表示指向的对象是一个常量 constexpr和常量表达式常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。for example123const int buf_size = 20; // 常量表达式const int limit = buf_size + 1 // 常量表达式int size = 10; // 不是常量表达式 constexpr : 由编译器来验证变量的值是否为常量表达式。声明为constexpr变量一定是一个常量,而且必须用常量表达式初始化。 constexpr 指针初始值一定要是nullptr 或 0 autoauto 一般会忽略掉顶层const，保留底层const。123456789int i = 0;const int ci = i, &amp;cr = ci;auto b = ci; // b是一个整数 const特性被忽略掉auto a = cr; // c是一个整数auto d = &amp;i; // d是一个整形指针auto e = &amp;ci; // e是一个指向常量整数的指针 底层constconst auto f = ci; // 这个时候f才有顶层const特性。 decltype declttype(( variable ))结果永远是引用 decltype( variable ) 只有variable本身是引用才是引用。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
</search>
