<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cs语法数据类型]]></title>
    <url>%2F2019%2F12%2F20%2Fcs%E8%AF%AD%E6%B3%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[学习C#数据类型 基本数据类型c#基本数据类型包括：整数类型， 浮点类型，decimal类型（特殊的浮点类型，能存储大数字而无表示错误）。 整数类型 \begin{array}\\ {\text {类型}} & { \text { 大小 }} & {范围} & {\text { BCL名称}}\\ {\text { sbyte }} & {8 \text { 位 }} & {-128-127} & {\text { system. SByte }} \\ {\text { byte }} & {8 \text { 位 }} & {0-255} & {\text { system. Byte }} \\ {\text { short }} & {16 \text {位 }} & {0-255} & {\text { System. Int16 } }\\ {\text { ushort }} & {16 \text { 位 }} & {0-32768-32767} & {\text { System. UInt 16 } } \\ {\text { int }} & {32 \text { 位 }} & {0-65535647483647} & {\text { system. Int 32 }} \\ {\text { uint }} & {32 \text { 位}} & {0-4294967295} & {\text { System. UInt 32 }} \\ {\text { Long }} & {64 \text { 位 }} & {-9223372036854775808-9223372036854775807}& {\text { System. Int 64 }} \\ {\text { ulong }} & {64 \text { 位 }}&{0-18446744073709551615} & {\text { system. UInt } 64} \end{array} BCL名称是基类库中的类型名称。 设计规范：指定数据类型时使用c#关键字而不是BCL名称，且保持一致。 浮点类型 \begin{array}\\ \hline \text{类型} & {大小} & { 范围 } & {BCL名称} & {有效数位} & {后缀} \\ \hline \text { float } & {32位} & {\pm 1.5 \times 10^{-3}-\pm 3.4 \times 10^{35}} & {\text { System. Single }} & {7} & {F \text { 或 f}} \\ \hline \text { double } & {64 \text { 位 }} & {\pm 5.0 \times 10^{-134}}{-\pm 1.7 \times 10^{100}} & {\text { System. Double }} & {15-16} & {\text { D 或 d}} \\ \hline \end{array}decimal类型c#提供了128位精度的十进制浮点类型。 \begin{array}\\ \hline \text {类型} & {大小 }& {范围} & {BCL名称} & { 有效数位 } & {后缀} \\ \hline \text { decimal } & 128 \text { 位 } &\left(-7.9 \times 10^{3}-7.9 \times 10^{8}\right) /\left(10^{6}-10^{8}\right) & \text { system. Decimal } & 28-29 & \text { M或 } m\\ \hline \end{array}decimal类型和浮点数不一样，decimal类型保证范围内所有十进制数都是精确的。所以0.1就是0.1,而不是近似值。 此外decimal类型精度很高，但是范围较小。]]></content>
      <categories>
        <category>c#本质论</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>c# 语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解cs泛型]]></title>
    <url>%2F2019%2F12%2F13%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cs%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这篇文章学习一下c#的泛型 基本概念泛型分为两种形式：泛型类型（接口，委托，结构，类）和 泛型方法，两者都是表示API的基本方法。 我们看下面的两个语句： 123Dictonary&lt;TKey, TValue&gt; // 未绑定泛型 Dictonary&lt;string, int&gt; // 已构造类型 类型参数是TKey, TValue，而类型实参是string, int。 类型参数“接收信息”，类型实参提供信息。 如果没有为泛型类型参数提供类型实参，那么这就是一个未绑定泛型类型。如果制定了类型实参，该类型就是一个已构造类型。 1234567891011public class Dictionary&lt;TKey, TValue&gt; // 声明泛型类型 : IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; // 实现泛型接口 &#123; public Dictionary() &#123; &#125; // 无参构造函数 public void Add(TKey key, TValue value) // 类型参数声明方法 &#123; &#125; &#125; // list&lt;T&gt; 读作list of T 泛型可以重载，只需要改变一下类型参数的数量。 泛型方法概念属于比较简单，我们通过之下的例子来说明 12345678910111213141516171819202122232425262728class Program &#123; static double TakeSquareRoot(int x) &#123; return Math.Sqrt(x); &#125; static void Main(string[] args) &#123; List&lt;int&gt; interges = new List&lt;int&gt;(); interges.Add(1); interges.Add(3); interges.Add(4); interges.Add(5); // &lt;int double&gt; 代表转换 Converter&lt;int, double&gt; converter = TakeSquareRoot; // 创建委托实例 List&lt;double&gt; doubles; doubles = interges.ConvertAll&lt;double&gt;(converter); // 调用泛型方法 foreach(double d in doubles) &#123; Console.WriteLine(d); &#125; &#125;&#125; 非泛型同样可以使用泛型方法 123456789101112131415161718192021class Program &#123; static List&lt;T&gt; MakeList&lt;T&gt; (T first, T second) &#123; List &lt;T&gt; list = new List&lt;T&gt;(); list.Add(first); list.Add(second); return list; &#125; static void Main(string[] args) &#123; List&lt;string&gt; list = MakeList&lt;string&gt;(&quot;line1&quot;, &quot;line2&quot;); foreach(string x in list) &#123; Console.WriteLine(x); &#125; &#125; &#125; 泛型的类型约束​ 类型约束是为了只有特定的类型调用，相当于制定了规则，从而判断哪些是泛型类型或泛型方法能接受的有效类型实参。 约束类型引用类型约束用于确保使用的类型是引用类型。 12345678910struct RefSample&lt;T&gt; where T : class // 有效 RefSample&lt;string&gt; RefSample&lt;int[]&gt; RefSample&lt;IDisposable&gt; // ..无效 RefSample&lt;Guid&gt; RefSample&lt;int&gt; RefSample 仍然是值类型，以强调被约束的类型参数和类型本身的差异。 值类型约束确保使用的类型实参是值类型。 123456789class ValSample&lt;T&gt; where T : struct // ..有效 ValSample&lt;int&gt; ValSample&lt;FileMode&gt; // ..无效 ValSample&lt;object&gt; ValSample&lt;StringBuilder&gt; ValSample类型本身是一个引用类型，虽然T被约束成值类型。 构造函数类型约束​ 此约束表示成T：new T ( ), 必须是所有类型参数的最后一个约束，它检查和类型实参是否有一个可用于创建类型实例的无参构造函数。 适用于： 所有值类型 所有没有显式声明构造函数的非静态，非抽象类 所有显式声明了一个公共无参构造函数的非抽象类 转换类型约束​ 允许你指定另一个类型，类型实参必须可以通过一致性，引用或装箱转换隐式地转换为该类型。你还可以规定一个类型实参必须可以转换为另一个类型实参，这成为类型参数约束。 1234567891011121314151617181920212223class Sample&lt;T&gt; where T : Stream Sample&lt;Stream&gt; // 一致性转换 Sample&lt;string&gt; // 无效 struct Sample&lt;T&gt; where T : IDispossable Sample&lt;SqlConnection&gt; // 引用转换 Sample&lt;StringBuilder&gt; // ..无效class Sample&lt;T&gt; where T : IComparable&lt;T&gt; Sample&lt;int&gt; //装箱转换 Sample&lt;FileInfo&gt; // 无效 class Sample&lt;T, U&gt; where T : U Sample&lt;Stream, IDisposable&gt; // 引用转换 Sample&lt;string, Idisposable&gt; // 无效// 可以指定多个接口，但只能指定一个类。class Sample&lt;T&gt; where T : Stream, IEnumerable&lt;string&gt;, IComparable&lt;int&gt;// ..error class Sample&lt;T&gt; where T : Stream, ArrayList,IComparable&lt;int&gt; 还有一系列限制：指定的类不可以是结构，密封类（比如string) 或者一下任何“特殊”类型。 System.Object System.Enum; System.ValueType; Systenm.Delegate; 组合约束组合约束是以上四种约束的组合，在c#中，不可能任何类型即是引用类型，又是值类型。遵循以下基本要点： class 或 struct 约束必须在其他约束之前，构造函数约束必须在最后。 指定类约束就不能指定值类型约束和引用类型约束 但是每一个值类型都有一个无参构造函数，所以假如已经有一个值类型约束，就不允许再指定一个构造函数约束。（如果T被约束成一个值类型，仍然可以在方法内部使用 new T() ）. 其次，如果存在多个转换类型约束，并且其中一个为类，那么它应该出现在接口的前面，而且我们不能多次指定同一个接口。不同的类型参数可以有不同的约束，它们分别由一个单独的where引入。 说这么多不如看看下面的例子 12345678910111213/* 有效 */// 值约束，转换类型约束，构造函数类型约束class Sample&lt;T&gt;:where T : class, IDisposable, new()&#123;...&#125; // 引用约束，转换类型约束class Sample&lt;T&gt; : where T : struct, IDisposable&#123;...&#125; // 前面的一句T是值类型约束，后面的U是引用约束加上T的转换类型约束class Sample&lt;T, U&gt; : where T : class where U: struct, T&#123;...&#125; // 前面T的是转换类型约束，后面的U是转换类型约束， 类写在前面class Sample&lt;T, U&gt; : where T : Stream where U : IDisposable&#123;...&#125; 12345678910111213141516171819/* 无效 */// 引用类型和值类型约束一起class Sample&lt;T&gt;where T : class, struct&#123;...&#125;// 值类型约束要在其他类型约束前面，指定类约束就不能指定值类型约束和引用类型约束class Sample&lt;T&gt; where T : Stream, class&#123;...&#125;// new() 必须是最后一个约束class Sample&lt;T&gt; where T : new(), Stream&#123;...&#125;// 类约束要在接口约束之前class Sample&lt;T&gt; where T : IDisposable, Stream&#123;...&#125;// 多次指定同一个接口class Sample&lt;T&gt; where T : XmlReader, IComparable, IComparable&#123;...&#125;// 因为T具有引用类型约束，不能作为U的约束class Sample&lt;T, U&gt; where T : struct where U class, T &#123;...&#125; 如果我们从规范中对约束进行分类，将其划分为主要约束，次要约束，构造函数约束。 主要约束：引用类型约束，值类型约束，使用类的转换类型约束 次要约束：接口或其他类型参数的转换类型约束 因此我们可以从规范上得知：三种约束都是可选的，但是主要约束只能有一个，次要约束只能有一个。 如果是值类型约束，就不能使用构造函数约束了，因为值类型默认都带有一个无参构造函数。 实现泛型默认值表达式有些情况虽然一般会被视为错误，但并不是十分严重的问题，也不应该视为异常。例如用户在键入的时候，由于输入一些非法的字符，程序假如能尝试解析一下文本，不必处理错误和捕捉异常，那么在容易出错的地方，可以提升性能。 在c#中，可以采取默认值表达式来解决这个问题。 123456789101112131415161718static int CompareToDefault&lt;T&gt;(T value) where T : IComparable&lt;T&gt; &#123; // CompareTo对于所有的引用类型的值都大于null,所以大于1. return value.CompareTo(default(T)); &#125; static void Main(string[] args) &#123; Console.WriteLine(CompareToDefault(&quot;x&quot;)); Console.WriteLine(CompareToDefault(10)); Console.WriteLine(CompareToDefault(0)); Console.WriteLine(CompareToDefault(-10)); Console.WriteLine(CompareToDefault(DateTime.MinValue)); &#125; 直接比较 如果一个类型参数是未约束的，那么只能在将该类型的值与null比较时才能使用== 和 ！= 操作符，不能直接的比较 如果类型实参是一个引用类型，会进行正常的引用比较。 如果为T提供的类型实参是一个非可空值类型，与null进行比较结果总是显示它们不相等。 如果类型实参是一个可空值类型，那么自然而然会与类型的控制进行比较。 如果一个类型参数被约束为值类型，就完全不能为它使用== 和 ！=。 如果被约束为引用类型，那么具体执行的比较将完全取决于类型参数被约束成什么类型。 如果它只是一个引用类型，那么执行只是简单的引用比较。 如果它被进一步约束成继承自某个重载了== 和 ！= 操作符的特定类型，就会使用重载的操作符。但要注意，假如调用者指定的类型实参恰巧也进行了重载，那么这个重载操作符是不会使用的。 123456789101112131415161718static bool AreReferencesEqual&lt;T&gt;(T first, T second) where T : class &#123; return first == second; &#125; static void Main(string[] args) &#123; string name = &quot;jon&quot;; string intro1 = &quot;My name is &quot; + name; string intro2 = &quot;My name is &quot; + name; Console.WriteLine(intro1 == intro2); Console.WriteLine(AreReferencesEqual(intro1, intro2)); &#125;&gt;&gt; true&gt;&gt; false]]></content>
      <categories>
        <category>深入理解c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 c# 值类型和引用类型]]></title>
    <url>%2F2019%2F12%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cs%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这篇文章学习一下c#的值类型和引用类型 简要分类 数组类型是引用类型，即使元素是值类型 枚举是值类型 委托类型是引用类型 接口类型是引用类型，但可以由值类型实现 类是引用类型，结构是值类型 三个误区： 结构是轻量级得类 引用类型保存在堆上，值类型保存在栈上引用类型一般都是创建在堆上，例如类实例，大但是值类型不一定都保存在栈上，比如类实例中属性，如果学过csapp,我们可以得知往往是函数参数和局部变量保存在栈上，静态变量则保存在堆上。 对象在c#中默认是通过引用传递的无论是引用传递还是值传递，永远不会传递对象本身，举个例子，在c/c++中使用指针，传递得是对象本身所在得地址而不是对象。]]></content>
      <categories>
        <category>深入理解c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const对指针和引用的限定]]></title>
    <url>%2F2019%2F12%2F08%2Fc%2B%2B-primer-const%E5%AF%B9%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E9%99%90%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[本文讲述const和指针，引用之间微妙的关系 const与引用const的引用（reference to const)简称为常量引用，引用的对象时常量还是非常量可以决定其所参与的操作，但是不会影响引用和对象的绑定关系。123456789const int ci = 1024;const int &amp;r1 = ci; // 引用及其对应的对象都是常量r1 = 42;int &amp;r2 = ci; // error, 使用一个非常量引用指向一个常量。int i = 42;const int &amp;r4 = r3; // 常量引用可以指向一个非常量，但是不允许通过r4对r3进行修改。 const与指针指向常量的指针(pointer to const) 指向常量的指针没有规定其所指的对象必须是一个常量,指向常量的指针是指不能通过指针来改变所指的变量的值。。 123456const double pi1 = 3.14;double pi2 = 3.14;// 下面两条赋值语句都是合法的。const double *cptr1 = &amp;pi1;const double *cptr2 = &amp;pi2; 常量指针(const pointer) 常量指针必须初始化，一旦初始化完成，那么它的值将不会在变化。 const poiter 不变的是指针本身的值而不是所指向的那个值，所以const pointer可以通过指针修改所指对象的值。123456int errNum = 0;int *const curErr = &amp;errNum;const double pi = 3.14;// 将*放在const可以说明指针是一个常量const double* const pip = &amp;pi; // pip是一个指向常量对象的常量指针。 const 介绍 顶层 const 代表对象本身是个常量。 底层 const 代表指针所指的对象是一个常量。 指针既可以是顶层const，也可以是底层const int i = 0; int *const p1 = &amp;i; // const pointer -- 这是顶层const const int ci = 42; // const var -- 这是顶层const const int *p2 = &amp;ci; // pointer to const -- 这是底层const const int *const p3 = p2; // 右边是顶层const， 左边是底层const const int &amp;r = ci; // 用于声明引用的const 都是底层const 如果进行copy时，顶层const的不受影响，但是底层const受限制。 进行copy的对象，拷入和拷出必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，但是反之不行。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第三章学习笔记]]></title>
    <url>%2F2019%2F12%2F08%2Fc%2B%2B-primer-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章主要介绍函数的定义和声明 函数函数的基础就不多说了。 函数的调用完成两项工作: 实参初始化函数对应的形参 将控制权转移给被调用函数 参数传递在c++中，多使用引用代替指针。 const形参和实参 const对 形参和实参 的作用和对变量的引用是一致的。 数组形参在cpp中，数组的两个特殊性质 不能copy，所以数组不能以值传递的方式使用数组参数。 不能用一个数组对另外一个数组进行初始化，也不能直接赋值 传递数组通常转换为12345// 以下三种语法是等价的。void function(int *);void function(int []);void function(int [10]); 管理指针形参的三种方式 使用标记，如C风格字符串 123456void print(const char *cp)&#123; if (cp) while (*cp) cout &lt;&lt; *cp++ &lt;&lt; " ";&#125; 使用标准库规范 1234567void print(const char* begin, const char* end)&#123; while (begin != end) &#123; cout &lt;&lt; *begin++ &lt;&lt; endl; &#125;&#125; 显示的传递一个代表数组大小的形参 1234567void print(const int ia[]， size_t size)&#123; for(size_t i = 0; i != size; ++i) &#123; cout &lt;&lt; ia[i] &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第三章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Fc%2B%2B-primer-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文初识标准库和迭代器,以及using在 c++11中新用处。 3.1 using 声明头文件不应该使用using 声明,因为头文件的内容会拷贝到所有引用它的文件中。这样容易产生名字冲突。 3.2 string初始化123456789string s1; // 默认初始化 空串string s2(s1); // s2是s1的副本。string s2 = s1; // 等价于s2(s1)。string s3("value"); // 等价写法 string s3 = "value";string s4(n, 'c'); // s4为连续n个字符c组成的字符串。 如果使用等号初始化一个变量的时候, 实际上执行的是拷贝初始化。反之则是直接初始化。 读写string 对象123456789int main()&#123; string str; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; string对象回自动忽略开头的空白(空格符, 换行符, 制表符等)并从第一个真正的字符开始读起,直到遇到下一个空白开始。 getline读取一整行，直到遇到换行符，所读的内容存入string对象中。换行符也被读进来了,但是被丢弃了,并没有存储到string对象中 size()函数的返回值是string::size_type类型,这是一个与机器无关的无符号整数类型。 所以当出现string.size()就不要使用int了。 string的比较关系运算符 &lt; &lt;= &gt; &gt;=都遵循以下的字典顺序 如果两个string对象的长度不同,而且较短string对象的每个字符都与较长string对象对应位置上的字符相同,就说较短的小于较长的。 如果两个string对象在某些对应位置上不一致,则string对象比较的结果实际上是第一对相异字符比较的结果。 3.3 vector实例化:编译器根据模板创建类和函数的过程。 初始化123456789101112131415vector(T) v1; // v1是一个空vector,执行T类型的默认初始化。vector(T) v2(v1); // v2中包含了v1所有元素的副本。vector(T) v2 = v1; //等价于v2(v1)。vector(T) v3(n, nval); // v3包含了n个重复的元素,每个元素的值都是val。vector(T) V4(n); // n个执行了T类型的值初始化的对象。// 列表初始化vector(T) v5&#123;a, b, c ...&#125; // v5包含了初始值个数的元素。vector(T) v5 = &#123;a, b, c ...&#125; // 等价于v5&#123;a, b, c ...&#125; 添加元素push_back()添加到vector的尾端。 c++ 更习惯于先创建空的vector对象,在运行的时候动态添加元素。 vector不能使用下标运算符去添加元素,但是可以用于访问已经存在的元素。 迭代器怎样称为一个有效的迭代器呢？ 或者指向某个元素,或者指向容器中尾元素的下一个位置 怎样获取迭代器？ begin() 和 end() ：end()获取的是一个尾后迭代器,指向尾部元素的下一个位置,仅仅是一个标记而已。 end() 返回的迭代器并不实际指示某个元素,所以不能对其进行递增或解引用的操作 但凡是使用了迭代器的循环体,都不要向使用迭代器所属的容器添加元素。因为会使迭代器失效。 迭代器运算所有标准库容器都有支持递增运算的迭代器。 string和vector迭代器支持更多运算。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第二章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Fc%2B%2B-primer-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章主要讲述了c++变量声明,以及各种修饰符的作用和技巧 初始化指变量在创建时给它赋值。赋值是将当前对象的值擦除掉,而以一个新值来代替.声明和定义的关系声明: 使得名字被程序所知道,一个文件如果想使用别处定义的名字则必须包含那个对那个名字的声明。 定义: 负责创建和名字关联的实体声明一个变量而非定义它,就在变量名前添加关键字extern,而且不要显示化的初始化变量。 123extern int i; // 声明但没定义int j; //声明并定义extern double pi = 3.1416; // 定义 变量只能被定义一次,但是可以被多次声明。 引用必须初始化 void* 可以存放任意对象的地址 const 限定符const对象必须初始化指向常量的指针和应用都是自以为是,就是不能通过本身去改变指向对象的值。 const 指针int *const ptr = &var; 常量指针必须初始化。 常量指针能不能通过指针去修改所指向对象的值,却决于指向对象的类型。 顶层const : 表示本身是一个常量 底层const : 表示指向的对象是一个常量 constexpr和常量表达式常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。123const int buf_size = 20; // 常量表达式const int limit = buf_size + 1 // 常量表达式int size = 10; // 不是常量表达式 constexpr : 由编译器来验证变量的值是否为常量表达式。声明为constexpr变量一定是一个常量,而且必须用常量表达式初始化。 constexpr 指针初始值一定要是nullptr 或 0 autoauto 一般会忽略掉顶层const，保留底层const。 123456789int i = 0;const int ci = i, &amp;cr = ci;auto b = ci; // b是一个整数 const特性被忽略掉auto a = cr; // c是一个整数auto d = &amp;i; // d是一个整形指针auto e = &amp;ci; // e是一个指向常量整数的指针 底层constconst auto f = ci; // 这个时候f才有顶层const特性。 decltype declttype(( variable ))结果永远是引用 decltype( variable ) 只有variable本身是引用才是引用。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
</search>
