<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++ primer 第三章学习笔记]]></title>
    <url>%2F2019%2F12%2F08%2F%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章主要介绍函数的定义和声明 六一.function函数的基础就不多说了。 函数的调用完成两项工作: 实参初始化函数对应的形参 将控制权转移给被调用函数]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第九章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Fc-primer-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章介绍了STL的语法。 9.1概述 name instruction vector 可变大小的数组,支持快速随机访问.在尾部之外的位置插入或删除元素可能很慢 deque 双端队列。支持快速随机访问,在头尾位置插入/删除速度很快 list 双向链表。只支持双向顺序访问.在list中任何位置插入/删除操作速度都很快。 forward_list 单向链表.只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 array 固定大小数组。支持快速随机访问,不能添加元素或删除元素。 string 随机访问快,与vector类似,但专门用于保存字符.在尾部插入/删除速度快。 选择容器的原则 首选vector,除非你有更好的选择 如果你的程序有很小的元素,且空间的额外开销很重要.则不要使用list或forward_list。 如果程序要求随机访问元素,应使用vector或deque。 如果程序要求在容器的中间插入或删除元素,应使用list或forward_list 如果程序要求在首尾端插入或删除元素,但不会在中间位置进行插入或删除操作。用deque 如果你不确定使用哪种容器,那么可以在程序中只使用vector和list公共的操作:使用迭代器,不使用下标操作,避免随机访问。这样,在必要时选择使用vector或list方便。 9.2容器操作表 类型别名 说明 iterator 迭代器类型 const_itertor 只读迭代器 size_type 无符号整数类型,足够保存容器类型最大可能容器的大小 difference_type 带符号整数类型,保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型,与value_type&amp;含义相同 构造函数 说明 C c 默认构造函数,空容器 C c1(c2) 构造c2的拷贝c1 C c(b, e) 构造c, 将迭代器b和e指定范围内的元素拷贝到c(不支持array) C c{a, b, c…}; 列表初始化 添加删除函数(不适用于array) 构造函数 说明 c.insert(args) 将args中的元素copy到c c.emplace(inits) 使用inits构造c中的一个元素 c.erase(args) 删除args指定的元素 c.clear() 删除c中的所有元素。 关系运算符所有容器都支持相等(不等)运算符,&lt;, &lt;=, &gt;, &gt;= (无序关联容器不支持) 9.2.1 迭代器forward_list 迭代器不支持递减运算符(–) 标准库使用左闭合范围的好处 假定begin和end构成了一个合法的迭代器范围. 如果begin和end相等,则范围为空 如果begin和end不等,则范围至少包含一个元素,且begin指向该范围中的第一个元素 我们可以对begin递增若干次,使得begin==end 9.2.2 容器类型成员值得注意的是: begin()返回是否为const_iterator 取决于容器类型是否为const. cbegin() cend()返回就是const_iterator 与容器类型是否为const无关。 auto 前面加const 保证了顶层const的特性。 9.2.4容器的初始化创建一个容器为了和容器实现匹配, 必须保证容器类型的高度一致。 12345678list &lt;string&gt; l1 = &#123;"sadd", "hello ", "world"&#125;;vector(const char*) a1 = &#123;"a", "an", "bre"&#125;;deque &lt;string&gt; d1(l1); vector&lt;string&gt; words(a1); // 容器类型匹配不一致。forward_list&lt;string&gt; words (a1.bengin(), a1.end()); // 但是可以通过两个迭代器所代表的范围来初始化。 9.2.5 赋值和交换容器的赋值运算 swap函数()swap(contains, contains)比拷贝元素要快。 除了array之外,swap函数不对任何元素进行拷贝,删除或插入操作,因此可以保证在常数时间完成。 除了string之外,swap函数执行之后,容器的迭代器,引用和指针都不会失效。 建议使用非成员函数版本的swap函数 assign操作不适用于关联容器和array 12345678910111213141516int main(int argc, char const *argv[])&#123; list&lt;int&gt; l1 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;int&gt; v2 = &#123;100, 1000, 10000&#125;; l1.assign(v2.begin(), v2.end()); for (auto it : l1) &#123; cout &lt;&lt; it &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; output: 100 1000 10000 arrayarray初始化必须指定大小]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第三章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Fc-primer-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文初识标准库和迭代器,以及using在 c++11中新用处。 3.1 using 声明头文件不应该使用using 声明,因为头文件的内容会拷贝到所有引用它的文件中。这样容易产生名字冲突。 3.2 string初始化123456789string s1; // 默认初始化 空串string s2(s1); // s2是s1的副本。string s2 = s1; // 等价于s2(s1)。string s3("value"); // 等价写法 string s3 = "value";string s4(n, 'c'); // s4为连续n个字符c组成的字符串。 如果使用等号初始化一个变量的时候, 实际上执行的是拷贝初始化。反之则是直接初始化。 读写string 对象123456789int main()&#123; string str; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; string对象回自动忽略开头的空白(空格符, 换行符, 制表符等)并从第一个真正的字符开始读起,直到遇到下一个空白开始。 getline读取一整行，直到遇到换行符，所读的内容存入string对象中。换行符也被读进来了,但是被丢弃了,并没有存储到string对象中。 size()函数的返回值是string::size_type类型,这是一个与机器无关的无符号整数类型。 所以当出现string.size()就不要使用int了。 string的比较关系运算符 &lt; &lt;= &gt; &gt;=都遵循以下的字典顺序 如果两个string对象的长度不同,而且较短string对象的每个字符都与较长string对象对应位置上的字符相同,就说较短的小于较长的。 如果两个string对象在某些对应位置上不一致,则string对象比较的结果实际上是第一对相异字符比较的结果。 3.3 vector实例化:编译器根据模板创建类和函数的过程。 初始化123456789101112131415vector(T) v1; // v1是一个空vector,执行T类型的默认初始化。vector(T) v2(v1); // v2中包含了v1所有元素的副本。vector(T) v2 = v1; //等价于v2(v1)。vector(T) v3(n, nval); // v3包含了n个重复的元素,每个元素的值都是val。vector(T) V4(n); // n个执行了T类型的值初始化的对象。// 列表初始化vector(T) v5&#123;a, b, c ...&#125; // v5包含了初始值个数的元素。vector(T) v5 = &#123;a, b, c ...&#125; // 等价于v5&#123;a, b, c ...&#125; 添加元素push_back()添加到vector的尾端。 c++ 更习惯于先创建空的vector对象,在运行的时候动态添加元素。 vector不能使用下标运算符去添加元素,但是可以用于访问已经存在的元素。 迭代器怎样称为一个有效的迭代器呢？ 或者指向某个元素,或者指向容器中尾元素的下一个位置 怎样获取迭代器 begin() 和 end()end()获取的是一个尾后迭代器,指向尾部元素的下一个位置,仅仅是一个标记而已。end() 返回的迭代器并不实际指示某个元素,所以不能对其进行递增或解引用的操作 但凡是使用了迭代器的循环体,都不要向使用迭代器所属的容器添加元素。因为会使迭代器失效。 迭代器运算所有标准库容器都有支持递增运算的迭代器。 string和vector迭代器支持更多运算。 instance meaning iter + n … iter - n … iter += n … iter -= n … iter - iter2 … &gt; &gt;= &lt; &lt;= … ###]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第二章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2Fc-primer-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章主要讲述了c++变量声明,以及各种修饰符的作用和技巧 初始化指变量在创建时给它赋值。赋值是将当前对象的值擦除掉,而以一个新值来代替.声明和定义的关系声明: 使得名字被程序所知道,一个文件如果想使用别处定义的名字则必须包含那个对那个名字的声明。 定义: 负责创建和名字关联的实体 声明一个变量而非定义它,就在变量名前添加关键字extern,而且不要显示化的初始化变量。 123extern int i; // 声明但没定义int j; //声明并定义extern double pi = 3.1416; // 定义 变量只能被定义一次,但是可以被多次声明。 引用必须初始化 void* 可以存放任意对象的地址 const 限定符const对象必须初始化指向常量的指针和应用都是自以为是,就是不能通过本身去改变指向对象的值。 const 指针 int *const ptr = &var; 常量指针必须初始化。 常量指针能不能通过指针去修改所指向对象的值,却决于指向对象的类型。 顶层const : 表示本身是一个常量 底层const : 表示指向的对象是一个常量 constexpr和常量表达式常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。for example123const int buf_size = 20; // 常量表达式const int limit = buf_size + 1 // 常量表达式int size = 10; // 不是常量表达式 constexpr : 由编译器来验证变量的值是否为常量表达式。声明为constexpr变量一定是一个常量,而且必须用常量表达式初始化。 constexpr 指针初始值一定要是nullptr 或 0 autoauto 一般会忽略掉顶层const，保留底层const。123456789int i = 0;const int ci = i, &amp;cr = ci;auto b = ci; // b是一个整数 const特性被忽略掉auto a = cr; // c是一个整数auto d = &amp;i; // d是一个整形指针auto e = &amp;ci; // e是一个指向常量整数的指针 底层constconst auto f = ci; // 这个时候f才有顶层const特性。 decltype declttype(( variable ))结果永远是引用 decltype( variable ) 只有variable本身是引用才是引用。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
</search>
