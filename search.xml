<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cs语法数据类型]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[学习C#数据类型 1.基本数据类型c#基本数据类型包括：整数类型， 浮点类型，decimal类型（特殊的浮点类型，能存储大数字而无表示错误）。 1.1 整数类型 \begin{array}\\ {\text {类型}} & { \text { 大小 }} & {范围} & {\text { BCL名称}}\\ {\text { sbyte }} & {8 \text { 位 }} & {-128-127} & {\text { system. SByte }} \\ {\text { byte }} & {8 \text { 位 }} & {0-255} & {\text { system. Byte }} \\ {\text { short }} & {16 \text {位 }} & {0-255} & {\text { System. Int16 } }\\ {\text { ushort }} & {16 \text { 位 }} & {0-32768-32767} & {\text { System. UInt 16 } } \\ {\text { int }} & {32 \text { 位 }} & {0-65535647483647} & {\text { system. Int 32 }} \\ {\text { uint }} & {32 \text { 位}} & {0-4294967295} & {\text { System. UInt 32 }} \\ {\text { Long }} & {64 \text { 位 }} & {-9223372036854775808-9223372036854775807}& {\text { System. Int 64 }} \\ {\text { ulong }} & {64 \text { 位 }}&{0-18446744073709551615} & {\text { system. UInt } 64} \end{array} BCL名称是基类库中的类型名称。 设计规范：指定数据类型时使用c#关键字而不是BCL名称，且保持一致。 1.2 浮点类型 \begin{array}\\ \hline \text{类型} & {大小} & { 范围 } & {BCL名称} & {有效数位} & {后缀} \\ \hline \text { float } & {32位} & {\pm 1.5 \times 10^{-3}-\pm 3.4 \times 10^{35}} & {\text { System. Single }} & {7} & {F \text { 或 f}} \\ \hline \text { double } & {64 \text { 位 }} & {\pm 5.0 \times 10^{-134}}{-\pm 1.7 \times 10^{100}} & {\text { System. Double }} & {15-16} & {\text { D 或 d}} \\ \hline \end{array}1.3 decimal类型c#提供了128位精度的十进制浮点类型。 \begin{array}\\ \hline \text {类型} & {大小 }& {范围} & {BCL名称} & { 有效数位 } & {后缀} \\ \hline \text { decimal } & 128 \text { 位 } &\left(-7.9 \times 10^{3}-7.9 \times 10^{8}\right) /\left(10^{6}-10^{8}\right) & \text { system. Decimal } & 28-29 & \text { M或 } m\\ \hline \end{array}decimal类型和浮点数不一样，decimal类型保证范围内所有十进制数都是精确的。所以0.1就是0.1,而不是近似值。 此外decimal类型精度很高，但是范围较小。 1.4 字面值表示源代码中的固定值。 // 如下面的42和1.523 Console.WriteLine(2); Console.WriteLine(1.523); 如果直接将值放入源代码中，被称为：硬编码， 通常这样做会使得代码很难维护，有可能需要进行再次编译才能继续使用。所有一种解决办法是直接读取配置文件中所设立的值，在需要改动的时候，直接进行修改配置文件的值即可。 对于字面值的输出： Console.WriteLine(1.618033988749895); // 输出不精确的值 >> 1.61803398874989 Console.WriteLine(1.618033988749895M); // 加上后缀，输出精确的值 >> 1.61803398874989 F和D将字面值分别显式声明没float,double。 对于整数类型，相应后缀是U, L, LU, UL。 无后缀的数值字面值按以下顺序解析成能存储该值的第一个数据类型：int, uint, long, ulong. 后缀为U的数值子面子按以下顺序解析成能存储该值的第一个数据类型：uint, ulong。 后缀为L的数值字面值按以下顺序解析成能存储该值的第一个数据类型：long, ulong. 2. 更多基本类型2.1 布尔类型占用一个字节。 2.2 字符类型char类型的BCL名称是：System.Char。 2.3 字符串类型string类型的BCL名称是：System.String. 支持字面值格式，逐字前缀@，允许$前缀进行字符串插值。string是一种“不可变”类型。 逐字和插值形式可以组合使用。 2.3.1 字面值格式构造字符串2.3.2 前缀@格式输出字符串@指明转义序列不被处理，结果是一个逐字字符串字面值，不仅将反斜杠当作普通字符，还会逐字解释所有空白字符。@开头的字符串唯一支持的转义序列是 “”代表是一个双引号。 2.3.4 $字符串插值字符串插值本质上事C#的一个语法糖。 Console.WriteLine($"Your full name is {firstName} {lastName}."); // 上述代码会转换成下面的代码 object[] args = new object[] { firstName, lastName }; Console.WriteLine(string.Format("Your full name is {0} {1}.", args)); 3. null 和 void3.1 nullnull可直接赋值给字符串变量，表明变量为“空”，不指向任何位置。 只能将null赋值给引用类型，指针类型， 可空值类型。 赋值了null的变量已设置，而未赋值的变量会造成编译时错误。 3.2 void void 本质上不是数据类型，它只是指出没有数据类型。 4.数据类型转换4.1 显式转换写法：（type）。 4.1.1 checked 和 unchecked转换static void Main(string[] args) { // checked快代码在运行时发生赋值溢出将引发异常。 checked { int n = int.MaxValue; n = n + 1; Console.WriteLine(n); } } c#提供一个命令行选项将默认行为从unchecked改为checked。 也支持unchecked快来强制不进行溢出检查，块中溢出的赋值不会引发异常。 4.2 隐式转换不多比比。 4.3 不适用转型操作符的类型转换4.3.1 Parse()方法每个数值数据类型都包含一个Parse() 方法，允许将字符串转换成对应的数值类型。 string text = "9.11E-31"; float value = float.Parse(text); 4.3.2 System.Convert进行类型转换string middleText = "241.626"; double middleC = System.Convert.ToDouble(middleText); bool boolean = System.Convert.ToBoolean(middleC); Convert只支持少量类型，且不可扩展，允许从bool char sbyte short int long ushort uint ulong float double decimal DateTime string 转换到这些类型中的任何一种。 4.3.3 ToString转换成string4.3.4 TryParse()和Parse()方法非常相似，只是转换失败而不是引发异常，而是返回false. static void Main(string[] args) { Console.Write("Enter a number: "); string input = Console.ReadLine(); /* c#7.0之前的版本对于number要先声明才能使用。 */ if (double.TryParse(input, out double number)) { Console.WriteLine(number); } else { Console.WriteLine( "The text entered was not a vaild number." ); } }]]></content>
      <categories>
        <category>c#本质论</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>c# 语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解cs泛型]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[这篇文章学习一下c#的泛型 基本概念泛型分为两种形式：泛型类型（接口，委托，结构，类）和 泛型方法，两者都是表示API的基本方法。 我们看下面的两个语句： Dictonary // 未绑定泛型 Dictonary // 已构造类型 类型参数是TKey, TValue，而类型实参是string, int。 类型参数“接收信息”，类型实参提供信息。 如果没有为泛型类型参数提供类型实参，那么这就是一个未绑定泛型类型。如果制定了类型实参，该类型就是一个已构造类型。 public class Dictionary // 声明泛型类型 : IEnumerable // 实现泛型接口 { public Dictionary() { } // 无参构造函数 public void Add(TKey key, TValue value) // 类型参数声明方法 { } } // list 读作list of T 泛型可以重载，只需要改变一下类型参数的数量。 泛型方法概念属于比较简单，我们通过之下的例子来说明 class Program { static double TakeSquareRoot(int x) { return Math.Sqrt(x); } static void Main(string[] args) { List interges = new List(); interges.Add(1); interges.Add(3); interges.Add(4); interges.Add(5); // 代表转换 Converter converter = TakeSquareRoot; // 创建委托实例 List doubles; doubles = interges.ConvertAll(converter); // 调用泛型方法 foreach(double d in doubles) { Console.WriteLine(d); } } } 非泛型同样可以使用泛型方法 class Program { static List MakeList (T first, T second) { List list = new List(); list.Add(first); list.Add(second); return list; } static void Main(string[] args) { List list = MakeList("line1", "line2"); foreach(string x in list) { Console.WriteLine(x); } } } 泛型的类型约束​ 类型约束是为了只有特定的类型调用，相当于制定了规则，从而判断哪些是泛型类型或泛型方法能接受的有效类型实参。 约束类型引用类型约束用于确保使用的类型是引用类型。 struct RefSample where T : class // 有效 RefSample RefSample RefSample // ..无效 RefSample RefSample RefSample 仍然是值类型，以强调被约束的类型参数和类型本身的差异。 值类型约束确保使用的类型实参是值类型。 class ValSample where T : struct // ..有效 ValSample ValSample // ..无效 ValSample ValSample ValSample类型本身是一个引用类型，虽然T被约束成值类型。 构造函数类型约束​ 此约束表示成T：new T ( ), 必须是所有类型参数的最后一个约束，它检查和类型实参是否有一个可用于创建类型实例的无参构造函数。 适用于： 所有值类型 所有没有显式声明构造函数的非静态，非抽象类 所有显式声明了一个公共无参构造函数的非抽象类 转换类型约束​ 允许你指定另一个类型，类型实参必须可以通过一致性，引用或装箱转换隐式地转换为该类型。你还可以规定一个类型实参必须可以转换为另一个类型实参，这成为类型参数约束。 class Sample where T : Stream Sample // 一致性转换 Sample // 无效 struct Sample where T : IDispossable Sample // 引用转换 Sample // ..无效 class Sample where T : IComparable Sample //装箱转换 Sample // 无效 class Sample where T : U Sample // 引用转换 Sample // 无效 // 可以指定多个接口，但只能指定一个类。 class Sample where T : Stream, IEnumerable, IComparable // ..error class Sample where T : Stream, ArrayList,IComparable 还有一系列限制：指定的类不可以是结构，密封类（比如string) 或者一下任何“特殊”类型。 System.Object System.Enum; System.ValueType; Systenm.Delegate; 组合约束组合约束是以上四种约束的组合，在c#中，不可能任何类型即是引用类型，又是值类型。遵循以下基本要点： class 或 struct 约束必须在其他约束之前，构造函数约束必须在最后。 指定类约束就不能指定值类型约束和引用类型约束 但是每一个值类型都有一个无参构造函数，所以假如已经有一个值类型约束，就不允许再指定一个构造函数约束。（如果T被约束成一个值类型，仍然可以在方法内部使用 new T() ）. 其次，如果存在多个转换类型约束，并且其中一个为类，那么它应该出现在接口的前面，而且我们不能多次指定同一个接口。不同的类型参数可以有不同的约束，它们分别由一个单独的where引入。 说这么多不如看看下面的例子 /* 有效 */ // 值约束，转换类型约束，构造函数类型约束 class Sample:where T : class, IDisposable, new(){...} // 引用约束，转换类型约束 class Sample : where T : struct, IDisposable{...} // 前面的一句T是值类型约束，后面的U是引用约束加上T的转换类型约束 class Sample : where T : class where U: struct, T{...} // 前面T的是转换类型约束，后面的U是转换类型约束， 类写在前面 class Sample : where T : Stream where U : IDisposable{...} /* 无效 */ // 引用类型和值类型约束一起 class Samplewhere T : class, struct{...} // 值类型约束要在其他类型约束前面，指定类约束就不能指定值类型约束和引用类型约束 class Sample where T : Stream, class{...} // new() 必须是最后一个约束 class Sample where T : new(), Stream{...} // 类约束要在接口约束之前 class Sample where T : IDisposable, Stream{...} // 多次指定同一个接口 class Sample where T : XmlReader, IComparable, IComparable{...} // 因为T具有引用类型约束，不能作为U的约束 class Sample where T : struct where U class, T {...} 如果我们从规范中对约束进行分类，将其划分为主要约束，次要约束，构造函数约束。 主要约束：引用类型约束，值类型约束，使用类的转换类型约束 次要约束：接口或其他类型参数的转换类型约束 因此我们可以从规范上得知：三种约束都是可选的，但是主要约束只能有一个，次要约束只能有一个。 如果是值类型约束，就不能使用构造函数约束了，因为值类型默认都带有一个无参构造函数。 实现泛型默认值表达式有些情况虽然一般会被视为错误，但并不是十分严重的问题，也不应该视为异常。例如用户在键入的时候，由于输入一些非法的字符，程序假如能尝试解析一下文本，不必处理错误和捕捉异常，那么在容易出错的地方，可以提升性能。 在c#中，可以采取默认值表达式来解决这个问题。 static int CompareToDefault(T value) where T : IComparable { // CompareTo对于所有的引用类型的值都大于null,所以大于1. return value.CompareTo(default(T)); } static void Main(string[] args) { Console.WriteLine(CompareToDefault("x")); Console.WriteLine(CompareToDefault(10)); Console.WriteLine(CompareToDefault(0)); Console.WriteLine(CompareToDefault(-10)); Console.WriteLine(CompareToDefault(DateTime.MinValue)); } 直接比较 如果一个类型参数是未约束的，那么只能在将该类型的值与null比较时才能使用== 和 ！= 操作符，不能直接的比较 如果类型实参是一个引用类型，会进行正常的引用比较。 如果为T提供的类型实参是一个非可空值类型，与null进行比较结果总是显示它们不相等。 如果类型实参是一个可空值类型，那么自然而然会与类型的控制进行比较。 如果一个类型参数被约束为值类型，就完全不能为它使用== 和 ！=。 如果被约束为引用类型，那么具体执行的比较将完全取决于类型参数被约束成什么类型。 如果它只是一个引用类型，那么执行只是简单的引用比较。 如果它被进一步约束成继承自某个重载了== 和 ！= 操作符的特定类型，就会使用重载的操作符。但要注意，假如调用者指定的类型实参恰巧也进行了重载，那么这个重载操作符是不会使用的。 ```c#static bool AreReferencesEqual(T first, T second) where T : class { return first == second; } static void Main(string[] args) { string name = &quot;jon&quot;; string intro1 = &quot;My name is &quot; + name; string intro2 = &quot;My name is &quot; + name; Console.WriteLine(intro1 == intro2); Console.WriteLine(AreReferencesEqual(intro1, intro2)); } truefalse ```]]></content>
      <categories>
        <category>深入理解c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 c# 值类型和引用类型]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[这篇文章学习一下c#的值类型和引用类型 简要分类 数组类型是引用类型，即使元素是值类型 枚举是值类型 委托类型是引用类型 接口类型是引用类型，但可以由值类型实现 类是引用类型，结构是值类型 三个误区： 结构是轻量级得类 引用类型保存在堆上，值类型保存在栈上引用类型一般都是创建在堆上，例如类实例，大但是值类型不一定都保存在栈上，比如类实例中属性，如果学过csapp,我们可以得知往往是函数参数和局部变量保存在栈上，静态变量则保存在堆上。 对象在c#中默认是通过引用传递的无论是引用传递还是值传递，永远不会传递对象本身，举个例子，在c/c++中使用指针，传递得是对象本身所在得地址而不是对象。]]></content>
      <categories>
        <category>深入理解c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const对指针和引用的限定]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[本文讲述const和指针，引用之间微妙的关系 const与引用const的引用（reference to const)简称为常量引用，引用的对象时常量还是非常量可以决定其所参与的操作，但是不会影响引用和对象的绑定关系。 const int ci = 1024; const int &r1 = ci; // 引用及其对应的对象都是常量 r1 = 42; int &r2 = ci; // error, 使用一个非常量引用指向一个常量。 int i = 42; const int &r4 = r3; // 常量引用可以指向一个非常量，但是不允许通过r4对r3进行修改。 const与指针指向常量的指针(pointer to const) 指向常量的指针没有规定其所指的对象必须是一个常量,指向常量的指针是指不能通过指针来改变所指的变量的值。。 const double pi1 = 3.14; double pi2 = 3.14; // 下面两条赋值语句都是合法的。 const double *cptr1 = &pi1; const double *cptr2 = &pi2; 常量指针(const pointer) 常量指针必须初始化，一旦初始化完成，那么它的值将不会在变化。 const poiter 不变的是指针本身的值而不是所指向的那个值，所以const pointer可以通过指针修改所指对象的值。```cppint errNum = 0;int *const curErr = &errNum; const double pi = 3.14;// 将放在const可以说明指针是一个常量const double const pip = &pi; // pip是一个指向常量对象的常量指针。 ### const 介绍 - 顶层 const 代表对象本身是个常量。 - 底层 const 代表指针所指的对象是一个常量。 - 指针既可以是顶层const，也可以是底层const ```cpp int i = 0; int *const p1 = &amp;i; // const pointer -- 这是顶层const const int ci = 42; // const var -- 这是顶层const const int *p2 = &amp;ci; // pointer to const -- 这是底层const const int *const p3 = p2; // 右边是顶层const， 左边是底层const const int &amp;r = ci; // 用于声明引用的const 都是底层const 如果进行copy时，顶层const的不受影响，但是底层const受限制。 进行copy的对象，拷入和拷出必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，但是反之不行。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第三章学习笔记]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[本章主要介绍函数的定义和声明 函数函数的基础就不多说了。 函数的调用完成两项工作: 实参初始化函数对应的形参 将控制权转移给被调用函数 参数传递在c++中，多使用引用代替指针。 const形参和实参 const对 形参和实参 的作用和对变量的引用是一致的。 数组形参在cpp中，数组的两个特殊性质 不能copy，所以数组不能以值传递的方式使用数组参数。 不能用一个数组对另外一个数组进行初始化，也不能直接赋值 传递数组通常转换为```cpp // 以下三种语法是等价的。void function(int *);void function(int []);void function(int [10]); ##### 管理指针形参的三种方式 - 使用标记，如C风格字符串 ```cpp void print(const char *cp) { if (cp) while (*cp) cout &lt;&lt; *cp++ &lt;&lt; &quot; &quot;; } 使用标准库规范 void print(const char* begin, const char* end) { while (begin != end) { cout < *begin++ < endl; } }]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第三章学习笔记]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[本文初识标准库和迭代器,以及using在 c++11中新用处。 3.1 using 声明头文件不应该使用using 声明,因为头文件的内容会拷贝到所有引用它的文件中。这样容易产生名字冲突。 3.2 string初始化string s1; // 默认初始化 空串 string s2(s1); // s2是s1的副本。 string s2 = s1; // 等价于s2(s1)。 string s3("value"); // 等价写法 string s3 = "value"; string s4(n, 'c'); // s4为连续n个字符c组成的字符串。 如果使用等号初始化一个变量的时候, 实际上执行的是拷贝初始化。反之则是直接初始化。 读写string 对象int main() { string str; cin >> str; cout < str < endl; return 0; }]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ primer 第二章学习笔记]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[本章主要讲述了c++变量声明,以及各种修饰符的作用和技巧 初始化指变量在创建时给它赋值。赋值是将当前对象的值擦除掉,而以一个新值来代替.声明和定义的关系声明: 使得名字被程序所知道,一个文件如果想使用别处定义的名字则必须包含那个对那个名字的声明。 定义: 负责创建和名字关联的实体声明一个变量而非定义它,就在变量名前添加关键字extern,而且不要显示化的初始化变量。 extern int i; // 声明但没定义 int j; //声明并定义 extern double pi = 3.1416; // 定义 变量只能被定义一次,但是可以被多次声明。 引用必须初始化 void* 可以存放任意对象的地址 const 限定符const对象必须初始化指向常量的指针和应用都是自以为是,就是不能通过本身去改变指向对象的值。 const 指针int *const ptr = &var; 常量指针必须初始化。 常量指针能不能通过指针去修改所指向对象的值,却决于指向对象的类型。 顶层const : 表示本身是一个常量 底层const : 表示指向的对象是一个常量 constexpr和常量表达式常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。const int buf_size = 20; // 常量表达式 const int limit = buf_size + 1 // 常量表达式 int size = 10; // 不是常量表达式 constexpr : 由编译器来验证变量的值是否为常量表达式。声明为constexpr变量一定是一个常量,而且必须用常量表达式初始化。 constexpr 指针初始值一定要是nullptr 或 0 autoauto 一般会忽略掉顶层const，保留底层const。 int i = 0; const int ci = i, &cr = ci; auto b = ci; // b是一个整数 const特性被忽略掉 auto a = cr; // c是一个整数 auto d = &i; // d是一个整形指针 auto e = &ci; // e是一个指向常量整数的指针 底层const const auto f = ci; // 这个时候f才有顶层const特性。 decltype declttype(( variable ))结果永远是引用 decltype( variable ) 只有variable本身是引用才是引用。]]></content>
      <categories>
        <category>c++ primer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 学习笔记</tag>
      </tags>
  </entry>
</search>
